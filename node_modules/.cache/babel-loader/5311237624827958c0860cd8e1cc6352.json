{"ast":null,"code":"import _toConsumableArray from \"/home/jet/Documents/buildspace/Gitfurry/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"/home/jet/Documents/buildspace/Gitfurry/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/home/jet/Documents/buildspace/Gitfurry/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/jet/Documents/buildspace/Gitfurry/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { TransactionInstruction } from \"@solana/web3.js\";\nimport { IdlError } from \"../../error\";\nimport { toInstruction, validateAccounts, translateAddress } from \"../common\";\nimport { splitArgsAndCtx } from \"../context\";\n\nvar InstructionNamespaceFactory = /*#__PURE__*/function () {\n  function InstructionNamespaceFactory() {\n    _classCallCheck(this, InstructionNamespaceFactory);\n  }\n\n  _createClass(InstructionNamespaceFactory, null, [{\n    key: \"build\",\n    value: function build(idlIx, encodeFn, programId) {\n      if (idlIx.name === \"_inner\") {\n        throw new IdlError(\"the _inner name is reserved\");\n      }\n\n      var ix = function ix() {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        var _splitArgsAndCtx = splitArgsAndCtx(idlIx, [].concat(args)),\n            _splitArgsAndCtx2 = _slicedToArray(_splitArgsAndCtx, 2),\n            ixArgs = _splitArgsAndCtx2[0],\n            ctx = _splitArgsAndCtx2[1];\n\n        validateAccounts(idlIx.accounts, ctx.accounts);\n        validateInstruction.apply(void 0, [idlIx].concat(args));\n        var keys = ix.accounts(ctx.accounts);\n\n        if (ctx.remainingAccounts !== undefined) {\n          keys.push.apply(keys, _toConsumableArray(ctx.remainingAccounts));\n        }\n\n        if (ctx.__private && ctx.__private.logAccounts) {\n          console.log(\"Outgoing account metas:\", keys);\n        }\n\n        return new TransactionInstruction({\n          keys: keys,\n          programId: programId,\n          data: encodeFn(idlIx.name, toInstruction.apply(void 0, [idlIx].concat(_toConsumableArray(ixArgs))))\n        });\n      }; // Utility fn for ordering the accounts for this instruction.\n\n\n      ix[\"accounts\"] = function (accs) {\n        return InstructionNamespaceFactory.accountsArray(accs, idlIx.accounts);\n      };\n\n      return ix;\n    }\n  }, {\n    key: \"accountsArray\",\n    value: function accountsArray(ctx, accounts) {\n      if (!ctx) {\n        return [];\n      }\n\n      return accounts.map(function (acc) {\n        // Nested accounts.\n        var nestedAccounts = \"accounts\" in acc ? acc.accounts : undefined;\n\n        if (nestedAccounts !== undefined) {\n          var rpcAccs = ctx[acc.name];\n          return InstructionNamespaceFactory.accountsArray(rpcAccs, acc.accounts).flat();\n        } else {\n          var account = acc;\n          return {\n            pubkey: translateAddress(ctx[acc.name]),\n            isWritable: account.isMut,\n            isSigner: account.isSigner\n          };\n        }\n      }).flat();\n    }\n  }]);\n\n  return InstructionNamespaceFactory;\n}(); // Throws error if any argument required for the `ix` is not given.\n\n\nexport { InstructionNamespaceFactory as default };\n\nfunction validateInstruction(ix) {// todo\n}","map":{"version":3,"sources":["../../../../src/program/namespace/instruction.ts"],"names":[],"mappings":";;;;AAAA,SAGE,sBAHF,QAIO,iBAJP;AAYA,SAAS,QAAT,QAAyB,aAAzB;AACA,SACE,aADF,EAEE,gBAFF,EAGE,gBAHF,QAKO,WALP;AAMA,SAAmB,eAAnB,QAA0C,YAA1C;;IASqB,2B;;;;;;;WACZ,eACL,KADK,EAEL,QAFK,EAGL,SAHK,EAGe;AAEpB,UAAI,KAAK,CAAC,IAAN,KAAe,QAAnB,EAA6B;AAC3B,cAAM,IAAI,QAAJ,CAAa,6BAAb,CAAN;AACD;;AAED,UAAM,EAAE,GAAG,SAAL,EAAK,GAEiB;AAAA,0CADvB,IACuB;AADvB,UAAA,IACuB;AAAA;;AAC1B,+BAAsB,eAAe,CAAC,KAAD,YAAY,IAAZ,EAArC;AAAA;AAAA,YAAO,MAAP;AAAA,YAAe,GAAf;;AACA,QAAA,gBAAgB,CAAC,KAAK,CAAC,QAAP,EAAiB,GAAG,CAAC,QAArB,CAAhB;AACA,QAAA,mBAAmB,MAAnB,UAAoB,KAApB,SAA8B,IAA9B;AAEA,YAAM,IAAI,GAAG,EAAE,CAAC,QAAH,CAAY,GAAG,CAAC,QAAhB,CAAb;;AAEA,YAAI,GAAG,CAAC,iBAAJ,KAA0B,SAA9B,EAAyC;AACvC,UAAA,IAAI,CAAC,IAAL,OAAA,IAAI,qBAAS,GAAG,CAAC,iBAAb,EAAJ;AACD;;AAED,YAAI,GAAG,CAAC,SAAJ,IAAiB,GAAG,CAAC,SAAJ,CAAc,WAAnC,EAAgD;AAC9C,UAAA,OAAO,CAAC,GAAR,CAAY,yBAAZ,EAAuC,IAAvC;AACD;;AACD,eAAO,IAAI,sBAAJ,CAA2B;AAChC,UAAA,IAAI,EAAJ,IADgC;AAEhC,UAAA,SAAS,EAAT,SAFgC;AAGhC,UAAA,IAAI,EAAE,QAAQ,CAAC,KAAK,CAAC,IAAP,EAAa,aAAa,MAAb,UAAc,KAAd,4BAAwB,MAAxB,GAAb;AAHkB,SAA3B,CAAP;AAKD,OArBD,CANoB,CA6BpB;;;AACA,MAAA,EAAE,CAAC,UAAD,CAAF,GAAiB,UAAC,IAAD,EAAsD;AACrE,eAAO,2BAA2B,CAAC,aAA5B,CAA0C,IAA1C,EAAgD,KAAK,CAAC,QAAtD,CAAP;AACD,OAFD;;AAIA,aAAO,EAAP;AACD;;;WAEM,uBACL,GADK,EAEL,QAFK,EAE8B;AAEnC,UAAI,CAAC,GAAL,EAAU;AACR,eAAO,EAAP;AACD;;AAED,aAAO,QAAQ,CACZ,GADI,CACA,UAAC,GAAD,EAAwB;AAC3B;AACA,YAAM,cAAc,GAClB,cAAc,GAAd,GAAoB,GAAG,CAAC,QAAxB,GAAmC,SADrC;;AAEA,YAAI,cAAc,KAAK,SAAvB,EAAkC;AAChC,cAAM,OAAO,GAAG,GAAG,CAAC,GAAG,CAAC,IAAL,CAAnB;AACA,iBAAO,2BAA2B,CAAC,aAA5B,CACL,OADK,EAEJ,GAAmB,CAAC,QAFhB,EAGL,IAHK,EAAP;AAID,SAND,MAMO;AACL,cAAM,OAAO,GAAe,GAA5B;AACA,iBAAO;AACL,YAAA,MAAM,EAAE,gBAAgB,CAAC,GAAG,CAAC,GAAG,CAAC,IAAL,CAAJ,CADnB;AAEL,YAAA,UAAU,EAAE,OAAO,CAAC,KAFf;AAGL,YAAA,QAAQ,EAAE,OAAO,CAAC;AAHb,WAAP;AAKD;AACF,OAnBI,EAoBJ,IApBI,EAAP;AAqBD;;;;KAuEH;;;SA7IqB,2B;;AA8IrB,SAAS,mBAAT,CAA6B,EAA7B,EAA+D,CAC7D;AACD","sourceRoot":"","sourcesContent":["import { TransactionInstruction, } from \"@solana/web3.js\";\nimport { IdlError } from \"../../error\";\nimport { toInstruction, validateAccounts, translateAddress, } from \"../common\";\nimport { splitArgsAndCtx } from \"../context\";\nexport default class InstructionNamespaceFactory {\n    static build(idlIx, encodeFn, programId) {\n        if (idlIx.name === \"_inner\") {\n            throw new IdlError(\"the _inner name is reserved\");\n        }\n        const ix = (...args) => {\n            const [ixArgs, ctx] = splitArgsAndCtx(idlIx, [...args]);\n            validateAccounts(idlIx.accounts, ctx.accounts);\n            validateInstruction(idlIx, ...args);\n            const keys = ix.accounts(ctx.accounts);\n            if (ctx.remainingAccounts !== undefined) {\n                keys.push(...ctx.remainingAccounts);\n            }\n            if (ctx.__private && ctx.__private.logAccounts) {\n                console.log(\"Outgoing account metas:\", keys);\n            }\n            return new TransactionInstruction({\n                keys,\n                programId,\n                data: encodeFn(idlIx.name, toInstruction(idlIx, ...ixArgs)),\n            });\n        };\n        // Utility fn for ordering the accounts for this instruction.\n        ix[\"accounts\"] = (accs) => {\n            return InstructionNamespaceFactory.accountsArray(accs, idlIx.accounts);\n        };\n        return ix;\n    }\n    static accountsArray(ctx, accounts) {\n        if (!ctx) {\n            return [];\n        }\n        return accounts\n            .map((acc) => {\n            // Nested accounts.\n            const nestedAccounts = \"accounts\" in acc ? acc.accounts : undefined;\n            if (nestedAccounts !== undefined) {\n                const rpcAccs = ctx[acc.name];\n                return InstructionNamespaceFactory.accountsArray(rpcAccs, acc.accounts).flat();\n            }\n            else {\n                const account = acc;\n                return {\n                    pubkey: translateAddress(ctx[acc.name]),\n                    isWritable: account.isMut,\n                    isSigner: account.isSigner,\n                };\n            }\n        })\n            .flat();\n    }\n}\n// Throws error if any argument required for the `ix` is not given.\nfunction validateInstruction(ix, ...args) {\n    // todo\n}\n//# sourceMappingURL=instruction.js.map"]},"metadata":{},"sourceType":"module"}