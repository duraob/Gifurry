{"ast":null,"code":"import _createForOfIteratorHelper from \"/home/jet/Documents/buildspace/Gitfurry/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _regeneratorRuntime from \"/home/jet/Documents/buildspace/Gitfurry/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/home/jet/Documents/buildspace/Gitfurry/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport assert from \"assert\";\nimport { PublicKey, Transaction, TransactionInstruction } from \"@solana/web3.js\";\nimport { chunks } from \"../utils/common\";\nimport { translateAddress } from \"../program/common\";\nimport { getProvider } from \"../provider\";\n/**\n * Sends a transaction to a program with the given accounts and instruction\n * data.\n */\n\nexport function invoke(_x, _x2, _x3, _x4) {\n  return _invoke.apply(this, arguments);\n}\n\nfunction _invoke() {\n  _invoke = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(programId, accounts, data, provider) {\n    var tx;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            programId = translateAddress(programId);\n\n            if (!provider) {\n              provider = getProvider();\n            }\n\n            tx = new Transaction();\n            tx.add(new TransactionInstruction({\n              programId: programId,\n              keys: accounts !== null && accounts !== void 0 ? accounts : [],\n              data: data\n            }));\n            _context.next = 6;\n            return provider.send(tx);\n\n          case 6:\n            return _context.abrupt(\"return\", _context.sent);\n\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _invoke.apply(this, arguments);\n}\n\nvar GET_MULTIPLE_ACCOUNTS_LIMIT = 99;\nexport function getMultipleAccounts(_x5, _x6) {\n  return _getMultipleAccounts.apply(this, arguments);\n}\n\nfunction _getMultipleAccounts() {\n  _getMultipleAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(connection, publicKeys) {\n    var batches, results;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            if (!(publicKeys.length <= GET_MULTIPLE_ACCOUNTS_LIMIT)) {\n              _context2.next = 6;\n              break;\n            }\n\n            _context2.next = 3;\n            return getMultipleAccountsCore(connection, publicKeys);\n\n          case 3:\n            return _context2.abrupt(\"return\", _context2.sent);\n\n          case 6:\n            batches = chunks(publicKeys, GET_MULTIPLE_ACCOUNTS_LIMIT);\n            _context2.next = 9;\n            return Promise.all(batches.map(function (batch) {\n              return getMultipleAccountsCore(connection, batch);\n            }));\n\n          case 9:\n            results = _context2.sent;\n            return _context2.abrupt(\"return\", results.flat());\n\n          case 11:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _getMultipleAccounts.apply(this, arguments);\n}\n\nfunction getMultipleAccountsCore(_x7, _x8) {\n  return _getMultipleAccountsCore.apply(this, arguments);\n}\n\nfunction _getMultipleAccountsCore() {\n  _getMultipleAccountsCore = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(connection, publicKeys) {\n    var args, res, accounts, _iterator, _step, account, value, executable, owner, lamports, data;\n\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            args = [publicKeys.map(function (k) {\n              return k.toBase58();\n            }), {\n              commitment: \"recent\"\n            }]; // @ts-ignore\n\n            _context3.next = 3;\n            return connection._rpcRequest(\"getMultipleAccounts\", args);\n\n          case 3:\n            res = _context3.sent;\n\n            if (!res.error) {\n              _context3.next = 6;\n              break;\n            }\n\n            throw new Error(\"failed to get info about accounts \" + publicKeys.map(function (k) {\n              return k.toBase58();\n            }).join(\", \") + \": \" + res.error.message);\n\n          case 6:\n            assert(typeof res.result !== \"undefined\");\n            accounts = [];\n            _iterator = _createForOfIteratorHelper(res.result.value);\n            _context3.prev = 9;\n\n            _iterator.s();\n\n          case 11:\n            if ((_step = _iterator.n()).done) {\n              _context3.next = 23;\n              break;\n            }\n\n            account = _step.value;\n            value = null;\n\n            if (!(account === null)) {\n              _context3.next = 17;\n              break;\n            }\n\n            accounts.push(null);\n            return _context3.abrupt(\"continue\", 21);\n\n          case 17:\n            if (res.result.value) {\n              executable = account.executable, owner = account.owner, lamports = account.lamports, data = account.data;\n              assert(data[1] === \"base64\");\n              value = {\n                executable: executable,\n                owner: new PublicKey(owner),\n                lamports: lamports,\n                data: Buffer.from(data[0], \"base64\")\n              };\n            }\n\n            if (!(value === null)) {\n              _context3.next = 20;\n              break;\n            }\n\n            throw new Error(\"Invalid response\");\n\n          case 20:\n            accounts.push(value);\n\n          case 21:\n            _context3.next = 11;\n            break;\n\n          case 23:\n            _context3.next = 28;\n            break;\n\n          case 25:\n            _context3.prev = 25;\n            _context3.t0 = _context3[\"catch\"](9);\n\n            _iterator.e(_context3.t0);\n\n          case 28:\n            _context3.prev = 28;\n\n            _iterator.f();\n\n            return _context3.finish(28);\n\n          case 31:\n            return _context3.abrupt(\"return\", accounts.map(function (account, idx) {\n              if (account === null) {\n                return null;\n              }\n\n              return {\n                publicKey: publicKeys[idx],\n                account: account\n              };\n            }));\n\n          case 32:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[9, 25, 28, 31]]);\n  }));\n  return _getMultipleAccountsCore.apply(this, arguments);\n}","map":{"version":3,"sources":["../../../src/utils/rpc.ts"],"names":[],"mappings":";;;AAAA,OAAO,MAAP,MAAmB,QAAnB;AACA,SAIE,SAJF,EAME,WANF,EAOE,sBAPF,QAQO,iBARP;AASA,SAAS,MAAT,QAAuB,iBAAvB;AACA,SAAkB,gBAAlB,QAA0C,mBAA1C;AACA,SAAmB,WAAnB,QAAsC,aAAtC;AAEA;;;AAGG;;AACH,gBAAsB,MAAtB;AAAA;AAAA;;;qEAAO,iBACL,SADK,EAEL,QAFK,EAGL,IAHK,EAIL,QAJK;AAAA;AAAA;AAAA;AAAA;AAAA;AAML,YAAA,SAAS,GAAG,gBAAgB,CAAC,SAAD,CAA5B;;AACA,gBAAI,CAAC,QAAL,EAAe;AACb,cAAA,QAAQ,GAAG,WAAW,EAAtB;AACD;;AAEK,YAAA,EAXD,GAWM,IAAI,WAAJ,EAXN;AAYL,YAAA,EAAE,CAAC,GAAH,CACE,IAAI,sBAAJ,CAA2B;AACzB,cAAA,SAAS,EAAT,SADyB;AAEzB,cAAA,IAAI,EAAE,QAAQ,KAAA,IAAR,IAAA,QAAQ,KAAA,KAAA,CAAR,GAAA,QAAA,GAAY,EAFO;AAGzB,cAAA,IAAI,EAAJ;AAHyB,aAA3B,CADF;AAZK;AAAA,mBAoBQ,QAAQ,CAAC,IAAT,CAAc,EAAd,CApBR;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AAuBP,IAAM,2BAA2B,GAAW,EAA5C;AAEA,gBAAsB,mBAAtB;AAAA;AAAA;;;kFAAO,kBACL,UADK,EAEL,UAFK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAMD,UAAU,CAAC,MAAX,IAAqB,2BANpB;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAOU,uBAAuB,CAAC,UAAD,EAAa,UAAb,CAPjC;;AAAA;AAAA;;AAAA;AASG,YAAA,OATH,GASa,MAAM,CAAC,UAAD,EAAa,2BAAb,CATnB;AAAA;AAAA,mBAUmB,OAAO,CAAC,GAAR,CAEpB,OAAO,CAAC,GAAR,CAAY,UAAC,KAAD;AAAA,qBAAW,uBAAuB,CAAC,UAAD,EAAa,KAAb,CAAlC;AAAA,aAAZ,CAFoB,CAVnB;;AAAA;AAUG,YAAA,OAVH;AAAA,8CAaI,OAAO,CAAC,IAAR,EAbJ;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;SAiBQ,uB;;;;;sFAAf,kBACE,UADF,EAEE,UAFF;AAAA;;AAAA;AAAA;AAAA;AAAA;AAMQ,YAAA,IANR,GAMe,CAAC,UAAU,CAAC,GAAX,CAAe,UAAC,CAAD;AAAA,qBAAO,CAAC,CAAC,QAAF,EAAP;AAAA,aAAf,CAAD,EAAsC;AAAE,cAAA,UAAU,EAAE;AAAd,aAAtC,CANf,EAOE;;AAPF;AAAA,mBAQoB,UAAU,CAAC,WAAX,CAAuB,qBAAvB,EAA8C,IAA9C,CARpB;;AAAA;AAQQ,YAAA,GARR;;AAAA,iBASM,GAAG,CAAC,KATV;AAAA;AAAA;AAAA;;AAAA,kBAUU,IAAI,KAAJ,CACJ,uCACE,UAAU,CAAC,GAAX,CAAe,UAAC,CAAD;AAAA,qBAAO,CAAC,CAAC,QAAF,EAAP;AAAA,aAAf,EAAoC,IAApC,CAAyC,IAAzC,CADF,GAEE,IAFF,GAGE,GAAG,CAAC,KAAJ,CAAU,OAJR,CAVV;;AAAA;AAiBE,YAAA,MAAM,CAAC,OAAO,GAAG,CAAC,MAAX,KAAsB,WAAvB,CAAN;AACM,YAAA,QAlBR,GAuBO,EAvBP;AAAA,mDAwBwB,GAAG,CAAC,MAAJ,CAAW,KAxBnC;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAwBa,YAAA,OAxBb;AAyBQ,YAAA,KAzBR,GA8Be,IA9Bf;;AAAA,kBA+BQ,OAAO,KAAK,IA/BpB;AAAA;AAAA;AAAA;;AAgCM,YAAA,QAAQ,CAAC,IAAT,CAAc,IAAd;AAhCN;;AAAA;AAmCI,gBAAI,GAAG,CAAC,MAAJ,CAAW,KAAf,EAAsB;AACZ,cAAA,UADY,GAC0B,OAD1B,CACZ,UADY,EACA,KADA,GAC0B,OAD1B,CACA,KADA,EACO,QADP,GAC0B,OAD1B,CACO,QADP,EACiB,IADjB,GAC0B,OAD1B,CACiB,IADjB;AAEpB,cAAA,MAAM,CAAC,IAAI,CAAC,CAAD,CAAJ,KAAY,QAAb,CAAN;AACA,cAAA,KAAK,GAAG;AACN,gBAAA,UAAU,EAAV,UADM;AAEN,gBAAA,KAAK,EAAE,IAAI,SAAJ,CAAc,KAAd,CAFD;AAGN,gBAAA,QAAQ,EAAR,QAHM;AAIN,gBAAA,IAAI,EAAE,MAAM,CAAC,IAAP,CAAY,IAAI,CAAC,CAAD,CAAhB,EAAqB,QAArB;AAJA,eAAR;AAMD;;AA5CL,kBA6CQ,KAAK,KAAK,IA7ClB;AAAA;AAAA;AAAA;;AAAA,kBA8CY,IAAI,KAAJ,CAAU,kBAAV,CA9CZ;;AAAA;AAgDI,YAAA,QAAQ,CAAC,IAAT,CAAc,KAAd;;AAhDJ;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAAA,8CAkDS,QAAQ,CAAC,GAAT,CAAa,UAAC,OAAD,EAAU,GAAV,EAAiB;AACnC,kBAAI,OAAO,KAAK,IAAhB,EAAsB;AACpB,uBAAO,IAAP;AACD;;AACD,qBAAO;AACL,gBAAA,SAAS,EAAE,UAAU,CAAC,GAAD,CADhB;AAEL,gBAAA,OAAO,EAAP;AAFK,eAAP;AAID,aARM,CAlDT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G","sourceRoot":"","sourcesContent":["import assert from \"assert\";\nimport { PublicKey, Transaction, TransactionInstruction, } from \"@solana/web3.js\";\nimport { chunks } from \"../utils/common\";\nimport { translateAddress } from \"../program/common\";\nimport { getProvider } from \"../provider\";\n/**\n * Sends a transaction to a program with the given accounts and instruction\n * data.\n */\nexport async function invoke(programId, accounts, data, provider) {\n    programId = translateAddress(programId);\n    if (!provider) {\n        provider = getProvider();\n    }\n    const tx = new Transaction();\n    tx.add(new TransactionInstruction({\n        programId,\n        keys: accounts !== null && accounts !== void 0 ? accounts : [],\n        data,\n    }));\n    return await provider.send(tx);\n}\nconst GET_MULTIPLE_ACCOUNTS_LIMIT = 99;\nexport async function getMultipleAccounts(connection, publicKeys) {\n    if (publicKeys.length <= GET_MULTIPLE_ACCOUNTS_LIMIT) {\n        return await getMultipleAccountsCore(connection, publicKeys);\n    }\n    else {\n        const batches = chunks(publicKeys, GET_MULTIPLE_ACCOUNTS_LIMIT);\n        const results = await Promise.all(batches.map((batch) => getMultipleAccountsCore(connection, batch)));\n        return results.flat();\n    }\n}\nasync function getMultipleAccountsCore(connection, publicKeys) {\n    const args = [publicKeys.map((k) => k.toBase58()), { commitment: \"recent\" }];\n    // @ts-ignore\n    const res = await connection._rpcRequest(\"getMultipleAccounts\", args);\n    if (res.error) {\n        throw new Error(\"failed to get info about accounts \" +\n            publicKeys.map((k) => k.toBase58()).join(\", \") +\n            \": \" +\n            res.error.message);\n    }\n    assert(typeof res.result !== \"undefined\");\n    const accounts = [];\n    for (const account of res.result.value) {\n        let value = null;\n        if (account === null) {\n            accounts.push(null);\n            continue;\n        }\n        if (res.result.value) {\n            const { executable, owner, lamports, data } = account;\n            assert(data[1] === \"base64\");\n            value = {\n                executable,\n                owner: new PublicKey(owner),\n                lamports,\n                data: Buffer.from(data[0], \"base64\"),\n            };\n        }\n        if (value === null) {\n            throw new Error(\"Invalid response\");\n        }\n        accounts.push(value);\n    }\n    return accounts.map((account, idx) => {\n        if (account === null) {\n            return null;\n        }\n        return {\n            publicKey: publicKeys[idx],\n            account,\n        };\n    });\n}\n//# sourceMappingURL=rpc.js.map"]},"metadata":{},"sourceType":"module"}