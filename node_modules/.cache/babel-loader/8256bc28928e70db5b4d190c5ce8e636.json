{"ast":null,"code":"import EventEmitter from \"eventemitter3\";\nimport camelCase from \"camelcase\";\nimport { SystemProgram } from \"@solana/web3.js\";\nimport Coder, { stateDiscriminator } from \"../../coder\";\nimport { getProvider } from \"../../\";\nimport { validateAccounts, parseIdlErrors } from \"../common\";\nimport { findProgramAddressSync, createWithSeedSync } from \"../../utils/pubkey\";\nimport InstructionNamespaceFactory from \"./instruction\";\nimport RpcNamespaceFactory from \"./rpc\";\nimport TransactionNamespaceFactory from \"./transaction\";\nexport default class StateFactory {\n  static build(idl, coder, programId, provider) {\n    if (idl.state === undefined) {\n      return undefined;\n    }\n\n    return new StateClient(idl, programId, provider, coder);\n  }\n\n}\n/**\n * A client for the program state. Similar to the base [[Program]] client,\n * one can use this to send transactions and read accounts for the state\n * abstraction.\n */\n\nexport class StateClient {\n  constructor(idl, programId) {\n    let provider = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : getProvider();\n    let coder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Coder(idl);\n    this.provider = provider;\n    this.coder = coder;\n    this._idl = idl;\n    this._programId = programId;\n    this._address = programStateAddress(programId);\n    this._sub = null; // Build namespaces.\n\n    const [instruction, transaction, rpc] = (() => {\n      var _a;\n\n      let instruction = {};\n      let transaction = {};\n      let rpc = {};\n      (_a = idl.state) === null || _a === void 0 ? void 0 : _a.methods.forEach(m => {\n        // Build instruction method.\n        const ixItem = InstructionNamespaceFactory.build(m, (ixName, ix) => coder.instruction.encodeState(ixName, ix), programId);\n\n        ixItem[\"accounts\"] = accounts => {\n          const keys = stateInstructionKeys(programId, provider, m, accounts);\n          return keys.concat(InstructionNamespaceFactory.accountsArray(accounts, m.accounts));\n        }; // Build transaction method.\n\n\n        const txItem = TransactionNamespaceFactory.build(m, ixItem); // Build RPC method.\n\n        const rpcItem = RpcNamespaceFactory.build(m, txItem, parseIdlErrors(idl), provider); // Attach them all to their respective namespaces.\n\n        const name = camelCase(m.name);\n        instruction[name] = ixItem;\n        transaction[name] = txItem;\n        rpc[name] = rpcItem;\n      });\n      return [instruction, transaction, rpc];\n    })();\n\n    this.instruction = instruction;\n    this.transaction = transaction;\n    this.rpc = rpc;\n  }\n  /**\n   * Returns the program ID owning the state.\n   */\n\n\n  get programId() {\n    return this._programId;\n  }\n  /**\n   * Returns the deserialized state account.\n   */\n\n\n  async fetch() {\n    const addr = this.address();\n    const accountInfo = await this.provider.connection.getAccountInfo(addr);\n\n    if (accountInfo === null) {\n      throw new Error(`Account does not exist ${addr.toString()}`);\n    } // Assert the account discriminator is correct.\n\n\n    const state = this._idl.state;\n\n    if (!state) {\n      throw new Error(\"State is not specified in IDL.\");\n    }\n\n    const expectedDiscriminator = await stateDiscriminator(state.struct.name);\n\n    if (expectedDiscriminator.compare(accountInfo.data.slice(0, 8))) {\n      throw new Error(\"Invalid account discriminator\");\n    }\n\n    return this.coder.state.decode(accountInfo.data);\n  }\n  /**\n   * Returns the state address.\n   */\n\n\n  address() {\n    return this._address;\n  }\n  /**\n   * Returns an `EventEmitter` with a `\"change\"` event that's fired whenever\n   * the state account cahnges.\n   */\n\n\n  subscribe(commitment) {\n    if (this._sub !== null) {\n      return this._sub.ee;\n    }\n\n    const ee = new EventEmitter();\n    const listener = this.provider.connection.onAccountChange(this.address(), acc => {\n      const account = this.coder.state.decode(acc.data);\n      ee.emit(\"change\", account);\n    }, commitment);\n    this._sub = {\n      ee,\n      listener\n    };\n    return ee;\n  }\n  /**\n   * Unsubscribes to state changes.\n   */\n\n\n  unsubscribe() {\n    if (this._sub !== null) {\n      this.provider.connection.removeAccountChangeListener(this._sub.listener).then(async () => {\n        this._sub = null;\n      }).catch(console.error);\n    }\n  }\n\n} // Calculates the deterministic address of the program's \"state\" account.\n\nfunction programStateAddress(programId) {\n  let [registrySigner] = findProgramAddressSync([], programId);\n  return createWithSeedSync(registrySigner, \"unversioned\", programId);\n} // Returns the common keys that are prepended to all instructions targeting\n// the \"state\" of a program.\n\n\nfunction stateInstructionKeys(programId, provider, m, accounts) {\n  if (m.name === \"new\") {\n    // Ctor `new` method.\n    const [programSigner] = findProgramAddressSync([], programId);\n    return [{\n      pubkey: provider.wallet.publicKey,\n      isWritable: false,\n      isSigner: true\n    }, {\n      pubkey: programStateAddress(programId),\n      isWritable: true,\n      isSigner: false\n    }, {\n      pubkey: programSigner,\n      isWritable: false,\n      isSigner: false\n    }, {\n      pubkey: SystemProgram.programId,\n      isWritable: false,\n      isSigner: false\n    }, {\n      pubkey: programId,\n      isWritable: false,\n      isSigner: false\n    }];\n  } else {\n    validateAccounts(m.accounts, accounts);\n    return [{\n      pubkey: programStateAddress(programId),\n      isWritable: true,\n      isSigner: false\n    }];\n  }\n}","map":{"version":3,"sources":["../../../../src/program/namespace/state.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import EventEmitter from \"eventemitter3\";\nimport camelCase from \"camelcase\";\nimport { SystemProgram, } from \"@solana/web3.js\";\nimport Coder, { stateDiscriminator } from \"../../coder\";\nimport { getProvider } from \"../../\";\nimport { validateAccounts, parseIdlErrors } from \"../common\";\nimport { findProgramAddressSync, createWithSeedSync } from \"../../utils/pubkey\";\nimport InstructionNamespaceFactory from \"./instruction\";\nimport RpcNamespaceFactory from \"./rpc\";\nimport TransactionNamespaceFactory from \"./transaction\";\nexport default class StateFactory {\n    static build(idl, coder, programId, provider) {\n        if (idl.state === undefined) {\n            return undefined;\n        }\n        return new StateClient(idl, programId, provider, coder);\n    }\n}\n/**\n * A client for the program state. Similar to the base [[Program]] client,\n * one can use this to send transactions and read accounts for the state\n * abstraction.\n */\nexport class StateClient {\n    constructor(idl, programId, \n    /**\n     * Returns the client's wallet and network provider.\n     */\n    provider = getProvider(), \n    /**\n     * Returns the coder.\n     */\n    coder = new Coder(idl)) {\n        this.provider = provider;\n        this.coder = coder;\n        this._idl = idl;\n        this._programId = programId;\n        this._address = programStateAddress(programId);\n        this._sub = null;\n        // Build namespaces.\n        const [instruction, transaction, rpc] = (() => {\n            var _a;\n            let instruction = {};\n            let transaction = {};\n            let rpc = {};\n            (_a = idl.state) === null || _a === void 0 ? void 0 : _a.methods.forEach((m) => {\n                // Build instruction method.\n                const ixItem = InstructionNamespaceFactory.build(m, (ixName, ix) => coder.instruction.encodeState(ixName, ix), programId);\n                ixItem[\"accounts\"] = (accounts) => {\n                    const keys = stateInstructionKeys(programId, provider, m, accounts);\n                    return keys.concat(InstructionNamespaceFactory.accountsArray(accounts, m.accounts));\n                };\n                // Build transaction method.\n                const txItem = TransactionNamespaceFactory.build(m, ixItem);\n                // Build RPC method.\n                const rpcItem = RpcNamespaceFactory.build(m, txItem, parseIdlErrors(idl), provider);\n                // Attach them all to their respective namespaces.\n                const name = camelCase(m.name);\n                instruction[name] = ixItem;\n                transaction[name] = txItem;\n                rpc[name] = rpcItem;\n            });\n            return [\n                instruction,\n                transaction,\n                rpc,\n            ];\n        })();\n        this.instruction = instruction;\n        this.transaction = transaction;\n        this.rpc = rpc;\n    }\n    /**\n     * Returns the program ID owning the state.\n     */\n    get programId() {\n        return this._programId;\n    }\n    /**\n     * Returns the deserialized state account.\n     */\n    async fetch() {\n        const addr = this.address();\n        const accountInfo = await this.provider.connection.getAccountInfo(addr);\n        if (accountInfo === null) {\n            throw new Error(`Account does not exist ${addr.toString()}`);\n        }\n        // Assert the account discriminator is correct.\n        const state = this._idl.state;\n        if (!state) {\n            throw new Error(\"State is not specified in IDL.\");\n        }\n        const expectedDiscriminator = await stateDiscriminator(state.struct.name);\n        if (expectedDiscriminator.compare(accountInfo.data.slice(0, 8))) {\n            throw new Error(\"Invalid account discriminator\");\n        }\n        return this.coder.state.decode(accountInfo.data);\n    }\n    /**\n     * Returns the state address.\n     */\n    address() {\n        return this._address;\n    }\n    /**\n     * Returns an `EventEmitter` with a `\"change\"` event that's fired whenever\n     * the state account cahnges.\n     */\n    subscribe(commitment) {\n        if (this._sub !== null) {\n            return this._sub.ee;\n        }\n        const ee = new EventEmitter();\n        const listener = this.provider.connection.onAccountChange(this.address(), (acc) => {\n            const account = this.coder.state.decode(acc.data);\n            ee.emit(\"change\", account);\n        }, commitment);\n        this._sub = {\n            ee,\n            listener,\n        };\n        return ee;\n    }\n    /**\n     * Unsubscribes to state changes.\n     */\n    unsubscribe() {\n        if (this._sub !== null) {\n            this.provider.connection\n                .removeAccountChangeListener(this._sub.listener)\n                .then(async () => {\n                this._sub = null;\n            })\n                .catch(console.error);\n        }\n    }\n}\n// Calculates the deterministic address of the program's \"state\" account.\nfunction programStateAddress(programId) {\n    let [registrySigner] = findProgramAddressSync([], programId);\n    return createWithSeedSync(registrySigner, \"unversioned\", programId);\n}\n// Returns the common keys that are prepended to all instructions targeting\n// the \"state\" of a program.\nfunction stateInstructionKeys(programId, provider, m, accounts) {\n    if (m.name === \"new\") {\n        // Ctor `new` method.\n        const [programSigner] = findProgramAddressSync([], programId);\n        return [\n            {\n                pubkey: provider.wallet.publicKey,\n                isWritable: false,\n                isSigner: true,\n            },\n            {\n                pubkey: programStateAddress(programId),\n                isWritable: true,\n                isSigner: false,\n            },\n            { pubkey: programSigner, isWritable: false, isSigner: false },\n            {\n                pubkey: SystemProgram.programId,\n                isWritable: false,\n                isSigner: false,\n            },\n            { pubkey: programId, isWritable: false, isSigner: false },\n        ];\n    }\n    else {\n        validateAccounts(m.accounts, accounts);\n        return [\n            {\n                pubkey: programStateAddress(programId),\n                isWritable: true,\n                isSigner: false,\n            },\n        ];\n    }\n}\n//# sourceMappingURL=state.js.map"]},"metadata":{},"sourceType":"module"}