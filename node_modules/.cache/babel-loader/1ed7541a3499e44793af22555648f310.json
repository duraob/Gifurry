{"ast":null,"code":"import _toConsumableArray from \"/home/jet/Documents/buildspace/Gifurry/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _regeneratorRuntime from \"/home/jet/Documents/buildspace/Gifurry/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/home/jet/Documents/buildspace/Gifurry/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _slicedToArray from \"/home/jet/Documents/buildspace/Gifurry/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/home/jet/Documents/buildspace/Gifurry/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/jet/Documents/buildspace/Gifurry/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport * as assert from \"assert\";\nvar LOG_START_INDEX = \"Program log: \".length;\nexport var EventManager = /*#__PURE__*/function () {\n  function EventManager(programId, provider, coder) {\n    _classCallCheck(this, EventManager);\n\n    this._programId = programId;\n    this._provider = provider;\n    this._eventParser = new EventParser(programId, coder);\n    this._eventCallbacks = new Map();\n    this._eventListeners = new Map();\n    this._listenerIdCount = 0;\n  }\n\n  _createClass(EventManager, [{\n    key: \"addEventListener\",\n    value: function addEventListener(eventName, callback) {\n      var _this = this;\n\n      var _a;\n\n      var listener = this._listenerIdCount;\n      this._listenerIdCount += 1; // Store the listener into the event map.\n\n      if (!(eventName in this._eventCallbacks)) {\n        this._eventListeners.set(eventName, []);\n      }\n\n      this._eventListeners.set(eventName, ((_a = this._eventListeners.get(eventName)) !== null && _a !== void 0 ? _a : []).concat(listener)); // Store the callback into the listener map.\n\n\n      this._eventCallbacks.set(listener, [eventName, callback]); // Create the subscription singleton, if needed.\n\n\n      if (this._onLogsSubscriptionId !== undefined) {\n        return listener;\n      }\n\n      this._onLogsSubscriptionId = this._provider.connection.onLogs(this._programId, function (logs, ctx) {\n        if (logs.err) {\n          console.error(logs);\n          return;\n        }\n\n        _this._eventParser.parseLogs(logs.logs, function (event) {\n          var allListeners = _this._eventListeners.get(event.name);\n\n          if (allListeners) {\n            allListeners.forEach(function (listener) {\n              var listenerCb = _this._eventCallbacks.get(listener);\n\n              if (listenerCb) {\n                var _listenerCb = _slicedToArray(listenerCb, 2),\n                    _callback = _listenerCb[1];\n\n                _callback(event.data, ctx.slot);\n              }\n            });\n          }\n        });\n      });\n      return listener;\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function () {\n      var _removeEventListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(listener) {\n        var callback, _callback2, eventName, listeners;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                // Get the callback.\n                callback = this._eventCallbacks.get(listener);\n\n                if (callback) {\n                  _context.next = 3;\n                  break;\n                }\n\n                throw new Error(\"Event listener \".concat(listener, \" doesn't exist!\"));\n\n              case 3:\n                _callback2 = _slicedToArray(callback, 1), eventName = _callback2[0]; // Get the listeners.\n\n                listeners = this._eventListeners.get(eventName);\n\n                if (listeners) {\n                  _context.next = 7;\n                  break;\n                }\n\n                throw new Error(\"Event listeners don't exist for \".concat(eventName, \"!\"));\n\n              case 7:\n                // Update both maps.\n                this._eventCallbacks.delete(listener);\n\n                listeners = listeners.filter(function (l) {\n                  return l !== listener;\n                });\n\n                if (listeners.length === 0) {\n                  this._eventListeners.delete(eventName);\n                } // Kill the websocket connection if all listeners have been removed.\n\n\n                if (!(this._eventCallbacks.size == 0)) {\n                  _context.next = 16;\n                  break;\n                }\n\n                assert.ok(this._eventListeners.size === 0);\n\n                if (!(this._onLogsSubscriptionId !== undefined)) {\n                  _context.next = 16;\n                  break;\n                }\n\n                _context.next = 15;\n                return this._provider.connection.removeOnLogsListener(this._onLogsSubscriptionId);\n\n              case 15:\n                this._onLogsSubscriptionId = undefined;\n\n              case 16:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function removeEventListener(_x) {\n        return _removeEventListener.apply(this, arguments);\n      }\n\n      return removeEventListener;\n    }()\n  }]);\n\n  return EventManager;\n}();\nexport var EventParser = /*#__PURE__*/function () {\n  function EventParser(programId, coder) {\n    _classCallCheck(this, EventParser);\n\n    this.coder = coder;\n    this.programId = programId;\n  } // Each log given, represents an array of messages emitted by\n  // a single transaction, which can execute many different programs across\n  // CPI boundaries. However, the subscription is only interested in the\n  // events emitted by *this* program. In achieving this, we keep track of the\n  // program execution context by parsing each log and looking for a CPI\n  // `invoke` call. If one exists, we know a new program is executing. So we\n  // push the programId onto a stack and switch the program context. This\n  // allows us to track, for a given log, which program was executing during\n  // its emission, thereby allowing us to know if a given log event was\n  // emitted by *this* program. If it was, then we parse the raw string and\n  // emit the event if the string matches the event being subscribed to.\n\n\n  _createClass(EventParser, [{\n    key: \"parseLogs\",\n    value: function parseLogs(logs, callback) {\n      var logScanner = new LogScanner(logs);\n      var execution = new ExecutionContext(logScanner.next());\n      var log = logScanner.next();\n\n      while (log !== null) {\n        var _this$handleLog = this.handleLog(execution, log),\n            _this$handleLog2 = _slicedToArray(_this$handleLog, 3),\n            event = _this$handleLog2[0],\n            newProgram = _this$handleLog2[1],\n            didPop = _this$handleLog2[2];\n\n        if (event) {\n          callback(event);\n        }\n\n        if (newProgram) {\n          execution.push(newProgram);\n        }\n\n        if (didPop) {\n          execution.pop();\n        }\n\n        log = logScanner.next();\n      }\n    } // Main log handler. Returns a three element array of the event, the\n    // next program that was invoked for CPI, and a boolean indicating if\n    // a program has completed execution (and thus should be popped off the\n    // execution stack).\n\n  }, {\n    key: \"handleLog\",\n    value: function handleLog(execution, log) {\n      // Executing program is this program.\n      if (execution.stack.length > 0 && execution.program() === this.programId.toString()) {\n        return this.handleProgramLog(log);\n      } // Executing program is not this program.\n      else {\n        return [null].concat(_toConsumableArray(this.handleSystemLog(log)));\n      }\n    } // Handles logs from *this* program.\n\n  }, {\n    key: \"handleProgramLog\",\n    value: function handleProgramLog(log) {\n      // This is a `msg!` log.\n      if (log.startsWith(\"Program log:\")) {\n        var logStr = log.slice(LOG_START_INDEX);\n        var event = this.coder.events.decode(logStr);\n        return [event, null, false];\n      } // System log.\n      else {\n        return [null].concat(_toConsumableArray(this.handleSystemLog(log)));\n      }\n    } // Handles logs when the current program being executing is *not* this.\n\n  }, {\n    key: \"handleSystemLog\",\n    value: function handleSystemLog(log) {\n      // System component.\n      var logStart = log.split(\":\")[0]; // Did the program finish executing?\n\n      if (logStart.match(/^Program (.*) success/g) !== null) {\n        return [null, true]; // Recursive call.\n      } else if (logStart.startsWith(\"Program \".concat(this.programId.toString(), \" invoke\"))) {\n        return [this.programId.toString(), false];\n      } // CPI call.\n      else if (logStart.includes(\"invoke\")) {\n        return [\"cpi\", false]; // Any string will do.\n      } else {\n        return [null, false];\n      }\n    }\n  }]);\n\n  return EventParser;\n}(); // Stack frame execution context, allowing one to track what program is\n// executing for a given log.\n\nvar ExecutionContext = /*#__PURE__*/function () {\n  function ExecutionContext(log) {\n    _classCallCheck(this, ExecutionContext);\n\n    var _a; // Assumes the first log in every transaction is an `invoke` log from the\n    // runtime.\n\n\n    var program = (_a = /^Program (.*) invoke.*$/g.exec(log)) === null || _a === void 0 ? void 0 : _a[1];\n\n    if (!program) {\n      throw new Error(\"Could not find program invocation log line\");\n    }\n\n    this.stack = [program];\n  }\n\n  _createClass(ExecutionContext, [{\n    key: \"program\",\n    value: function program() {\n      assert.ok(this.stack.length > 0);\n      return this.stack[this.stack.length - 1];\n    }\n  }, {\n    key: \"push\",\n    value: function push(newProgram) {\n      this.stack.push(newProgram);\n    }\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      assert.ok(this.stack.length > 0);\n      this.stack.pop();\n    }\n  }]);\n\n  return ExecutionContext;\n}();\n\nvar LogScanner = /*#__PURE__*/function () {\n  function LogScanner(logs) {\n    _classCallCheck(this, LogScanner);\n\n    this.logs = logs;\n  }\n\n  _createClass(LogScanner, [{\n    key: \"next\",\n    value: function next() {\n      if (this.logs.length === 0) {\n        return null;\n      }\n\n      var l = this.logs[0];\n      this.logs = this.logs.slice(1);\n      return l;\n    }\n  }]);\n\n  return LogScanner;\n}();","map":{"version":3,"sources":["../../../src/program/event.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as assert from \"assert\";\nconst LOG_START_INDEX = \"Program log: \".length;\nexport class EventManager {\n    constructor(programId, provider, coder) {\n        this._programId = programId;\n        this._provider = provider;\n        this._eventParser = new EventParser(programId, coder);\n        this._eventCallbacks = new Map();\n        this._eventListeners = new Map();\n        this._listenerIdCount = 0;\n    }\n    addEventListener(eventName, callback) {\n        var _a;\n        let listener = this._listenerIdCount;\n        this._listenerIdCount += 1;\n        // Store the listener into the event map.\n        if (!(eventName in this._eventCallbacks)) {\n            this._eventListeners.set(eventName, []);\n        }\n        this._eventListeners.set(eventName, ((_a = this._eventListeners.get(eventName)) !== null && _a !== void 0 ? _a : []).concat(listener));\n        // Store the callback into the listener map.\n        this._eventCallbacks.set(listener, [eventName, callback]);\n        // Create the subscription singleton, if needed.\n        if (this._onLogsSubscriptionId !== undefined) {\n            return listener;\n        }\n        this._onLogsSubscriptionId = this._provider.connection.onLogs(this._programId, (logs, ctx) => {\n            if (logs.err) {\n                console.error(logs);\n                return;\n            }\n            this._eventParser.parseLogs(logs.logs, (event) => {\n                const allListeners = this._eventListeners.get(event.name);\n                if (allListeners) {\n                    allListeners.forEach((listener) => {\n                        const listenerCb = this._eventCallbacks.get(listener);\n                        if (listenerCb) {\n                            const [, callback] = listenerCb;\n                            callback(event.data, ctx.slot);\n                        }\n                    });\n                }\n            });\n        });\n        return listener;\n    }\n    async removeEventListener(listener) {\n        // Get the callback.\n        const callback = this._eventCallbacks.get(listener);\n        if (!callback) {\n            throw new Error(`Event listener ${listener} doesn't exist!`);\n        }\n        const [eventName] = callback;\n        // Get the listeners.\n        let listeners = this._eventListeners.get(eventName);\n        if (!listeners) {\n            throw new Error(`Event listeners don't exist for ${eventName}!`);\n        }\n        // Update both maps.\n        this._eventCallbacks.delete(listener);\n        listeners = listeners.filter((l) => l !== listener);\n        if (listeners.length === 0) {\n            this._eventListeners.delete(eventName);\n        }\n        // Kill the websocket connection if all listeners have been removed.\n        if (this._eventCallbacks.size == 0) {\n            assert.ok(this._eventListeners.size === 0);\n            if (this._onLogsSubscriptionId !== undefined) {\n                await this._provider.connection.removeOnLogsListener(this._onLogsSubscriptionId);\n                this._onLogsSubscriptionId = undefined;\n            }\n        }\n    }\n}\nexport class EventParser {\n    constructor(programId, coder) {\n        this.coder = coder;\n        this.programId = programId;\n    }\n    // Each log given, represents an array of messages emitted by\n    // a single transaction, which can execute many different programs across\n    // CPI boundaries. However, the subscription is only interested in the\n    // events emitted by *this* program. In achieving this, we keep track of the\n    // program execution context by parsing each log and looking for a CPI\n    // `invoke` call. If one exists, we know a new program is executing. So we\n    // push the programId onto a stack and switch the program context. This\n    // allows us to track, for a given log, which program was executing during\n    // its emission, thereby allowing us to know if a given log event was\n    // emitted by *this* program. If it was, then we parse the raw string and\n    // emit the event if the string matches the event being subscribed to.\n    parseLogs(logs, callback) {\n        const logScanner = new LogScanner(logs);\n        const execution = new ExecutionContext(logScanner.next());\n        let log = logScanner.next();\n        while (log !== null) {\n            let [event, newProgram, didPop] = this.handleLog(execution, log);\n            if (event) {\n                callback(event);\n            }\n            if (newProgram) {\n                execution.push(newProgram);\n            }\n            if (didPop) {\n                execution.pop();\n            }\n            log = logScanner.next();\n        }\n    }\n    // Main log handler. Returns a three element array of the event, the\n    // next program that was invoked for CPI, and a boolean indicating if\n    // a program has completed execution (and thus should be popped off the\n    // execution stack).\n    handleLog(execution, log) {\n        // Executing program is this program.\n        if (execution.stack.length > 0 &&\n            execution.program() === this.programId.toString()) {\n            return this.handleProgramLog(log);\n        }\n        // Executing program is not this program.\n        else {\n            return [null, ...this.handleSystemLog(log)];\n        }\n    }\n    // Handles logs from *this* program.\n    handleProgramLog(log) {\n        // This is a `msg!` log.\n        if (log.startsWith(\"Program log:\")) {\n            const logStr = log.slice(LOG_START_INDEX);\n            const event = this.coder.events.decode(logStr);\n            return [event, null, false];\n        }\n        // System log.\n        else {\n            return [null, ...this.handleSystemLog(log)];\n        }\n    }\n    // Handles logs when the current program being executing is *not* this.\n    handleSystemLog(log) {\n        // System component.\n        const logStart = log.split(\":\")[0];\n        // Did the program finish executing?\n        if (logStart.match(/^Program (.*) success/g) !== null) {\n            return [null, true];\n            // Recursive call.\n        }\n        else if (logStart.startsWith(`Program ${this.programId.toString()} invoke`)) {\n            return [this.programId.toString(), false];\n        }\n        // CPI call.\n        else if (logStart.includes(\"invoke\")) {\n            return [\"cpi\", false]; // Any string will do.\n        }\n        else {\n            return [null, false];\n        }\n    }\n}\n// Stack frame execution context, allowing one to track what program is\n// executing for a given log.\nclass ExecutionContext {\n    constructor(log) {\n        var _a;\n        // Assumes the first log in every transaction is an `invoke` log from the\n        // runtime.\n        const program = (_a = /^Program (.*) invoke.*$/g.exec(log)) === null || _a === void 0 ? void 0 : _a[1];\n        if (!program) {\n            throw new Error(`Could not find program invocation log line`);\n        }\n        this.stack = [program];\n    }\n    program() {\n        assert.ok(this.stack.length > 0);\n        return this.stack[this.stack.length - 1];\n    }\n    push(newProgram) {\n        this.stack.push(newProgram);\n    }\n    pop() {\n        assert.ok(this.stack.length > 0);\n        this.stack.pop();\n    }\n}\nclass LogScanner {\n    constructor(logs) {\n        this.logs = logs;\n    }\n    next() {\n        if (this.logs.length === 0) {\n            return null;\n        }\n        let l = this.logs[0];\n        this.logs = this.logs.slice(1);\n        return l;\n    }\n}\n//# sourceMappingURL=event.js.map"]},"metadata":{},"sourceType":"module"}