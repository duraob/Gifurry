{"ast":null,"code":"import _toConsumableArray from \"/home/jet/Documents/buildspace/Gitfurry/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _regeneratorRuntime from \"/home/jet/Documents/buildspace/Gitfurry/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/home/jet/Documents/buildspace/Gitfurry/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/home/jet/Documents/buildspace/Gitfurry/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/jet/Documents/buildspace/Gitfurry/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport camelCase from \"camelcase\";\nimport EventEmitter from \"eventemitter3\";\nimport * as bs58 from \"bs58\";\nimport { SystemProgram } from \"@solana/web3.js\";\nimport Coder, { ACCOUNT_DISCRIMINATOR_SIZE, accountSize, AccountsCoder } from \"../../coder\";\nimport { translateAddress } from \"../common\";\nimport { getProvider } from \"../../\";\nimport * as pubkeyUtil from \"../../utils/pubkey\";\nimport * as rpcUtil from \"../../utils/rpc\";\n\nvar AccountFactory = /*#__PURE__*/function () {\n  function AccountFactory() {\n    _classCallCheck(this, AccountFactory);\n  }\n\n  _createClass(AccountFactory, null, [{\n    key: \"build\",\n    value: function build(idl, coder, programId, provider) {\n      var _a;\n\n      var accountFns = {};\n      (_a = idl.accounts) === null || _a === void 0 ? void 0 : _a.forEach(function (idlAccount) {\n        var name = camelCase(idlAccount.name);\n        accountFns[name] = new AccountClient(idl, idlAccount, programId, provider, coder);\n      });\n      return accountFns;\n    }\n  }]);\n\n  return AccountFactory;\n}();\n\nexport { AccountFactory as default };\nexport var AccountClient = /*#__PURE__*/function () {\n  function AccountClient(idl, idlAccount, programId, provider, coder) {\n    _classCallCheck(this, AccountClient);\n\n    var _a;\n\n    this._idlAccount = idlAccount;\n    this._programId = programId;\n    this._provider = provider !== null && provider !== void 0 ? provider : getProvider();\n    this._coder = coder !== null && coder !== void 0 ? coder : new Coder(idl);\n    this._size = ACCOUNT_DISCRIMINATOR_SIZE + ((_a = accountSize(idl, idlAccount)) !== null && _a !== void 0 ? _a : 0);\n  }\n  /**\n   * Returns the number of bytes in this account.\n   */\n\n\n  _createClass(AccountClient, [{\n    key: \"size\",\n    get: function get() {\n      return this._size;\n    }\n    /**\n     * Returns the program ID owning all accounts.\n     */\n\n  }, {\n    key: \"programId\",\n    get: function get() {\n      return this._programId;\n    }\n    /**\n     * Returns the client's wallet and network provider.\n     */\n\n  }, {\n    key: \"provider\",\n    get: function get() {\n      return this._provider;\n    }\n    /**\n     * Returns the coder.\n     */\n\n  }, {\n    key: \"coder\",\n    get: function get() {\n      return this._coder;\n    }\n    /**\n     * Returns a deserialized account, returning null if it doesn't exist.\n     *\n     * @param address The address of the account to fetch.\n     */\n\n  }, {\n    key: \"fetchNullable\",\n    value: function () {\n      var _fetchNullable = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(address) {\n        var accountInfo, discriminator;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this._provider.connection.getAccountInfo(translateAddress(address));\n\n              case 2:\n                accountInfo = _context.sent;\n\n                if (!(accountInfo === null)) {\n                  _context.next = 5;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", null);\n\n              case 5:\n                // Assert the account discriminator is correct.\n                discriminator = AccountsCoder.accountDiscriminator(this._idlAccount.name);\n\n                if (!discriminator.compare(accountInfo.data.slice(0, 8))) {\n                  _context.next = 8;\n                  break;\n                }\n\n                throw new Error(\"Invalid account discriminator\");\n\n              case 8:\n                return _context.abrupt(\"return\", this._coder.accounts.decode(this._idlAccount.name, accountInfo.data));\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function fetchNullable(_x) {\n        return _fetchNullable.apply(this, arguments);\n      }\n\n      return fetchNullable;\n    }()\n    /**\n     * Returns a deserialized account.\n     *\n     * @param address The address of the account to fetch.\n     */\n\n  }, {\n    key: \"fetch\",\n    value: function () {\n      var _fetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(address) {\n        var data;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.fetchNullable(address);\n\n              case 2:\n                data = _context2.sent;\n\n                if (!(data === null)) {\n                  _context2.next = 5;\n                  break;\n                }\n\n                throw new Error(\"Account does not exist \".concat(address.toString()));\n\n              case 5:\n                return _context2.abrupt(\"return\", data);\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function fetch(_x2) {\n        return _fetch.apply(this, arguments);\n      }\n\n      return fetch;\n    }()\n    /**\n     * Returns multiple deserialized accounts.\n     * Accounts not found or with wrong discriminator are returned as null.\n     *\n     * @param addresses The addresses of the accounts to fetch.\n     */\n\n  }, {\n    key: \"fetchMultiple\",\n    value: function () {\n      var _fetchMultiple = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(addresses) {\n        var _this = this;\n\n        var accounts, discriminator;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return rpcUtil.getMultipleAccounts(this._provider.connection, addresses.map(function (address) {\n                  return translateAddress(address);\n                }));\n\n              case 2:\n                accounts = _context3.sent;\n                discriminator = AccountsCoder.accountDiscriminator(this._idlAccount.name); // Decode accounts where discriminator is correct, null otherwise\n\n                return _context3.abrupt(\"return\", accounts.map(function (account) {\n                  if (account == null) {\n                    return null;\n                  }\n\n                  if (discriminator.compare(account === null || account === void 0 ? void 0 : account.account.data.slice(0, 8))) {\n                    return null;\n                  }\n\n                  return _this._coder.accounts.decode(_this._idlAccount.name, account === null || account === void 0 ? void 0 : account.account.data);\n                }));\n\n              case 5:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function fetchMultiple(_x3) {\n        return _fetchMultiple.apply(this, arguments);\n      }\n\n      return fetchMultiple;\n    }()\n    /**\n     * Returns all instances of this account type for the program.\n     *\n     * @param filters User-provided filters to narrow the results from `connection.getProgramAccounts`.\n     *\n     *                When filters are not defined this method returns all\n     *                the account instances.\n     *\n     *                When filters are of type `Buffer`, the filters are appended\n     *                after the discriminator.\n     *\n     *                When filters are of type `GetProgramAccountsFilter[]`,\n     *                filters are appended after the discriminator filter.\n     */\n\n  }, {\n    key: \"all\",\n    value: function () {\n      var _all = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(filters) {\n        var _this2 = this;\n\n        var discriminator, resp;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                discriminator = AccountsCoder.accountDiscriminator(this._idlAccount.name);\n                _context4.next = 3;\n                return this._provider.connection.getProgramAccounts(this._programId, {\n                  commitment: this._provider.connection.commitment,\n                  filters: [{\n                    memcmp: {\n                      offset: 0,\n                      bytes: bs58.encode(filters instanceof Buffer ? Buffer.concat([discriminator, filters]) : discriminator)\n                    }\n                  }].concat(_toConsumableArray(Array.isArray(filters) ? filters : []))\n                });\n\n              case 3:\n                resp = _context4.sent;\n                return _context4.abrupt(\"return\", resp.map(function (_ref) {\n                  var pubkey = _ref.pubkey,\n                      account = _ref.account;\n                  return {\n                    publicKey: pubkey,\n                    account: _this2._coder.accounts.decode(_this2._idlAccount.name, account.data)\n                  };\n                }));\n\n              case 5:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function all(_x4) {\n        return _all.apply(this, arguments);\n      }\n\n      return all;\n    }()\n    /**\n     * Returns an `EventEmitter` emitting a \"change\" event whenever the account\n     * changes.\n     */\n\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(address, commitment) {\n      var _this3 = this;\n\n      var sub = subscriptions.get(address.toString());\n\n      if (sub) {\n        return sub.ee;\n      }\n\n      var ee = new EventEmitter();\n      address = translateAddress(address);\n\n      var listener = this._provider.connection.onAccountChange(address, function (acc) {\n        var account = _this3._coder.accounts.decode(_this3._idlAccount.name, acc.data);\n\n        ee.emit(\"change\", account);\n      }, commitment);\n\n      subscriptions.set(address.toString(), {\n        ee: ee,\n        listener: listener\n      });\n      return ee;\n    }\n    /**\n     * Unsubscribes from the account at the given address.\n     */\n\n  }, {\n    key: \"unsubscribe\",\n    value: function () {\n      var _unsubscribe = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(address) {\n        var sub;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                sub = subscriptions.get(address.toString());\n\n                if (sub) {\n                  _context5.next = 4;\n                  break;\n                }\n\n                console.warn(\"Address is not subscribed\");\n                return _context5.abrupt(\"return\");\n\n              case 4:\n                if (!subscriptions) {\n                  _context5.next = 7;\n                  break;\n                }\n\n                _context5.next = 7;\n                return this._provider.connection.removeAccountChangeListener(sub.listener).then(function () {\n                  subscriptions.delete(address.toString());\n                }).catch(console.error);\n\n              case 7:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function unsubscribe(_x5) {\n        return _unsubscribe.apply(this, arguments);\n      }\n\n      return unsubscribe;\n    }()\n    /**\n     * Returns an instruction for creating this account.\n     */\n\n  }, {\n    key: \"createInstruction\",\n    value: function () {\n      var _createInstruction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(signer, sizeOverride) {\n        var size;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                size = this.size;\n                _context6.t0 = SystemProgram;\n                _context6.t1 = this._provider.wallet.publicKey;\n                _context6.t2 = signer.publicKey;\n                _context6.t3 = sizeOverride !== null && sizeOverride !== void 0 ? sizeOverride : size;\n                _context6.next = 7;\n                return this._provider.connection.getMinimumBalanceForRentExemption(sizeOverride !== null && sizeOverride !== void 0 ? sizeOverride : size);\n\n              case 7:\n                _context6.t4 = _context6.sent;\n                _context6.t5 = this._programId;\n                _context6.t6 = {\n                  fromPubkey: _context6.t1,\n                  newAccountPubkey: _context6.t2,\n                  space: _context6.t3,\n                  lamports: _context6.t4,\n                  programId: _context6.t5\n                };\n                return _context6.abrupt(\"return\", _context6.t0.createAccount.call(_context6.t0, _context6.t6));\n\n              case 11:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function createInstruction(_x6, _x7) {\n        return _createInstruction.apply(this, arguments);\n      }\n\n      return createInstruction;\n    }()\n    /**\n     * @deprecated since version 14.0.\n     *\n     * Function returning the associated account. Args are keys to associate.\n     * Order matters.\n     */\n\n  }, {\n    key: \"associated\",\n    value: function () {\n      var _associated = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        var addr,\n            _args7 = arguments;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return this.associatedAddress.apply(this, _args7);\n\n              case 2:\n                addr = _context7.sent;\n                _context7.next = 5;\n                return this.fetch(addr);\n\n              case 5:\n                return _context7.abrupt(\"return\", _context7.sent);\n\n              case 6:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function associated() {\n        return _associated.apply(this, arguments);\n      }\n\n      return associated;\n    }()\n    /**\n     * @deprecated since version 14.0.\n     *\n     * Function returning the associated address. Args are keys to associate.\n     * Order matters.\n     */\n\n  }, {\n    key: \"associatedAddress\",\n    value: function () {\n      var _associatedAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n        var _len,\n            args,\n            _key,\n            _args8 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                for (_len = _args8.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                  args[_key] = _args8[_key];\n                }\n\n                _context8.next = 3;\n                return pubkeyUtil.associated.apply(pubkeyUtil, [this._programId].concat(args));\n\n              case 3:\n                return _context8.abrupt(\"return\", _context8.sent);\n\n              case 4:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function associatedAddress() {\n        return _associatedAddress.apply(this, arguments);\n      }\n\n      return associatedAddress;\n    }()\n  }]);\n\n  return AccountClient;\n}(); // Tracks all subscriptions.\n\nvar subscriptions = new Map();","map":{"version":3,"sources":["../../../../src/program/namespace/account.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import camelCase from \"camelcase\";\nimport EventEmitter from \"eventemitter3\";\nimport * as bs58 from \"bs58\";\nimport { SystemProgram, } from \"@solana/web3.js\";\nimport Coder, { ACCOUNT_DISCRIMINATOR_SIZE, accountSize, AccountsCoder, } from \"../../coder\";\nimport { translateAddress } from \"../common\";\nimport { getProvider } from \"../../\";\nimport * as pubkeyUtil from \"../../utils/pubkey\";\nimport * as rpcUtil from \"../../utils/rpc\";\nexport default class AccountFactory {\n    static build(idl, coder, programId, provider) {\n        var _a;\n        const accountFns = {};\n        (_a = idl.accounts) === null || _a === void 0 ? void 0 : _a.forEach((idlAccount) => {\n            const name = camelCase(idlAccount.name);\n            accountFns[name] = new AccountClient(idl, idlAccount, programId, provider, coder);\n        });\n        return accountFns;\n    }\n}\nexport class AccountClient {\n    constructor(idl, idlAccount, programId, provider, coder) {\n        var _a;\n        this._idlAccount = idlAccount;\n        this._programId = programId;\n        this._provider = provider !== null && provider !== void 0 ? provider : getProvider();\n        this._coder = coder !== null && coder !== void 0 ? coder : new Coder(idl);\n        this._size =\n            ACCOUNT_DISCRIMINATOR_SIZE + ((_a = accountSize(idl, idlAccount)) !== null && _a !== void 0 ? _a : 0);\n    }\n    /**\n     * Returns the number of bytes in this account.\n     */\n    get size() {\n        return this._size;\n    }\n    /**\n     * Returns the program ID owning all accounts.\n     */\n    get programId() {\n        return this._programId;\n    }\n    /**\n     * Returns the client's wallet and network provider.\n     */\n    get provider() {\n        return this._provider;\n    }\n    /**\n     * Returns the coder.\n     */\n    get coder() {\n        return this._coder;\n    }\n    /**\n     * Returns a deserialized account, returning null if it doesn't exist.\n     *\n     * @param address The address of the account to fetch.\n     */\n    async fetchNullable(address) {\n        const accountInfo = await this._provider.connection.getAccountInfo(translateAddress(address));\n        if (accountInfo === null) {\n            return null;\n        }\n        // Assert the account discriminator is correct.\n        const discriminator = AccountsCoder.accountDiscriminator(this._idlAccount.name);\n        if (discriminator.compare(accountInfo.data.slice(0, 8))) {\n            throw new Error(\"Invalid account discriminator\");\n        }\n        return this._coder.accounts.decode(this._idlAccount.name, accountInfo.data);\n    }\n    /**\n     * Returns a deserialized account.\n     *\n     * @param address The address of the account to fetch.\n     */\n    async fetch(address) {\n        const data = await this.fetchNullable(address);\n        if (data === null) {\n            throw new Error(`Account does not exist ${address.toString()}`);\n        }\n        return data;\n    }\n    /**\n     * Returns multiple deserialized accounts.\n     * Accounts not found or with wrong discriminator are returned as null.\n     *\n     * @param addresses The addresses of the accounts to fetch.\n     */\n    async fetchMultiple(addresses) {\n        const accounts = await rpcUtil.getMultipleAccounts(this._provider.connection, addresses.map((address) => translateAddress(address)));\n        const discriminator = AccountsCoder.accountDiscriminator(this._idlAccount.name);\n        // Decode accounts where discriminator is correct, null otherwise\n        return accounts.map((account) => {\n            if (account == null) {\n                return null;\n            }\n            if (discriminator.compare(account === null || account === void 0 ? void 0 : account.account.data.slice(0, 8))) {\n                return null;\n            }\n            return this._coder.accounts.decode(this._idlAccount.name, account === null || account === void 0 ? void 0 : account.account.data);\n        });\n    }\n    /**\n     * Returns all instances of this account type for the program.\n     *\n     * @param filters User-provided filters to narrow the results from `connection.getProgramAccounts`.\n     *\n     *                When filters are not defined this method returns all\n     *                the account instances.\n     *\n     *                When filters are of type `Buffer`, the filters are appended\n     *                after the discriminator.\n     *\n     *                When filters are of type `GetProgramAccountsFilter[]`,\n     *                filters are appended after the discriminator filter.\n     */\n    async all(filters) {\n        const discriminator = AccountsCoder.accountDiscriminator(this._idlAccount.name);\n        let resp = await this._provider.connection.getProgramAccounts(this._programId, {\n            commitment: this._provider.connection.commitment,\n            filters: [\n                {\n                    memcmp: {\n                        offset: 0,\n                        bytes: bs58.encode(filters instanceof Buffer\n                            ? Buffer.concat([discriminator, filters])\n                            : discriminator),\n                    },\n                },\n                ...(Array.isArray(filters) ? filters : []),\n            ],\n        });\n        return resp.map(({ pubkey, account }) => {\n            return {\n                publicKey: pubkey,\n                account: this._coder.accounts.decode(this._idlAccount.name, account.data),\n            };\n        });\n    }\n    /**\n     * Returns an `EventEmitter` emitting a \"change\" event whenever the account\n     * changes.\n     */\n    subscribe(address, commitment) {\n        const sub = subscriptions.get(address.toString());\n        if (sub) {\n            return sub.ee;\n        }\n        const ee = new EventEmitter();\n        address = translateAddress(address);\n        const listener = this._provider.connection.onAccountChange(address, (acc) => {\n            const account = this._coder.accounts.decode(this._idlAccount.name, acc.data);\n            ee.emit(\"change\", account);\n        }, commitment);\n        subscriptions.set(address.toString(), {\n            ee,\n            listener,\n        });\n        return ee;\n    }\n    /**\n     * Unsubscribes from the account at the given address.\n     */\n    async unsubscribe(address) {\n        let sub = subscriptions.get(address.toString());\n        if (!sub) {\n            console.warn(\"Address is not subscribed\");\n            return;\n        }\n        if (subscriptions) {\n            await this._provider.connection\n                .removeAccountChangeListener(sub.listener)\n                .then(() => {\n                subscriptions.delete(address.toString());\n            })\n                .catch(console.error);\n        }\n    }\n    /**\n     * Returns an instruction for creating this account.\n     */\n    async createInstruction(signer, sizeOverride) {\n        const size = this.size;\n        return SystemProgram.createAccount({\n            fromPubkey: this._provider.wallet.publicKey,\n            newAccountPubkey: signer.publicKey,\n            space: sizeOverride !== null && sizeOverride !== void 0 ? sizeOverride : size,\n            lamports: await this._provider.connection.getMinimumBalanceForRentExemption(sizeOverride !== null && sizeOverride !== void 0 ? sizeOverride : size),\n            programId: this._programId,\n        });\n    }\n    /**\n     * @deprecated since version 14.0.\n     *\n     * Function returning the associated account. Args are keys to associate.\n     * Order matters.\n     */\n    async associated(...args) {\n        const addr = await this.associatedAddress(...args);\n        return await this.fetch(addr);\n    }\n    /**\n     * @deprecated since version 14.0.\n     *\n     * Function returning the associated address. Args are keys to associate.\n     * Order matters.\n     */\n    async associatedAddress(...args) {\n        return await pubkeyUtil.associated(this._programId, ...args);\n    }\n}\n// Tracks all subscriptions.\nconst subscriptions = new Map();\n//# sourceMappingURL=account.js.map"]},"metadata":{},"sourceType":"module"}