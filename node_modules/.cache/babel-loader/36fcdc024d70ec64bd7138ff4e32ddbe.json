{"ast":null,"code":"import { snakeCase } from \"snake-case\";\nimport { sha256 } from \"js-sha256\";\nimport { IdlError } from \"../error\";\nexport function accountSize(idl, idlAccount) {\n  if (idlAccount.type.kind === \"enum\") {\n    let variantSizes = idlAccount.type.variants.map(variant => {\n      if (variant.fields === undefined) {\n        return 0;\n      }\n\n      return variant.fields.map(f => {\n        if (!(typeof f === \"object\" && \"name\" in f)) {\n          throw new Error(\"Tuple enum variants not yet implemented.\");\n        }\n\n        return typeSize(idl, f.type);\n      }).reduce((a, b) => a + b);\n    });\n    return Math.max(...variantSizes) + 1;\n  }\n\n  if (idlAccount.type.fields === undefined) {\n    return 0;\n  }\n\n  return idlAccount.type.fields.map(f => typeSize(idl, f.type)).reduce((a, b) => a + b, 0);\n} // Returns the size of the type in bytes. For variable length types, just return\n// 1. Users should override this value in such cases.\n\nfunction typeSize(idl, ty) {\n  var _a, _b;\n\n  switch (ty) {\n    case \"bool\":\n      return 1;\n\n    case \"u8\":\n      return 1;\n\n    case \"i8\":\n      return 1;\n\n    case \"i16\":\n      return 2;\n\n    case \"u16\":\n      return 2;\n\n    case \"u32\":\n      return 4;\n\n    case \"i32\":\n      return 4;\n\n    case \"u64\":\n      return 8;\n\n    case \"i64\":\n      return 8;\n\n    case \"u128\":\n      return 16;\n\n    case \"i128\":\n      return 16;\n\n    case \"bytes\":\n      return 1;\n\n    case \"string\":\n      return 1;\n\n    case \"publicKey\":\n      return 32;\n\n    default:\n      if (\"vec\" in ty) {\n        return 1;\n      }\n\n      if (\"option\" in ty) {\n        return 1 + typeSize(idl, ty.option);\n      }\n\n      if (\"defined\" in ty) {\n        const filtered = (_b = (_a = idl.types) === null || _a === void 0 ? void 0 : _a.filter(t => t.name === ty.defined)) !== null && _b !== void 0 ? _b : [];\n\n        if (filtered.length !== 1) {\n          throw new IdlError(`Type not found: ${JSON.stringify(ty)}`);\n        }\n\n        let typeDef = filtered[0];\n        return accountSize(idl, typeDef);\n      }\n\n      if (\"array\" in ty) {\n        let arrayTy = ty.array[0];\n        let arraySize = ty.array[1];\n        return typeSize(idl, arrayTy) * arraySize;\n      }\n\n      throw new Error(`Invalid type ${JSON.stringify(ty)}`);\n  }\n} // Not technically sighash, since we don't include the arguments, as Rust\n// doesn't allow function overloading.\n\n\nexport function sighash(nameSpace, ixName) {\n  let name = snakeCase(ixName);\n  let preimage = `${nameSpace}:${name}`;\n  return Buffer.from(sha256.digest(preimage)).slice(0, 8);\n}","map":{"version":3,"sources":["../../../src/coder/common.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { snakeCase } from \"snake-case\";\nimport { sha256 } from \"js-sha256\";\nimport { IdlError } from \"../error\";\nexport function accountSize(idl, idlAccount) {\n    if (idlAccount.type.kind === \"enum\") {\n        let variantSizes = idlAccount.type.variants.map((variant) => {\n            if (variant.fields === undefined) {\n                return 0;\n            }\n            return variant.fields\n                .map((f) => {\n                if (!(typeof f === \"object\" && \"name\" in f)) {\n                    throw new Error(\"Tuple enum variants not yet implemented.\");\n                }\n                return typeSize(idl, f.type);\n            })\n                .reduce((a, b) => a + b);\n        });\n        return Math.max(...variantSizes) + 1;\n    }\n    if (idlAccount.type.fields === undefined) {\n        return 0;\n    }\n    return idlAccount.type.fields\n        .map((f) => typeSize(idl, f.type))\n        .reduce((a, b) => a + b, 0);\n}\n// Returns the size of the type in bytes. For variable length types, just return\n// 1. Users should override this value in such cases.\nfunction typeSize(idl, ty) {\n    var _a, _b;\n    switch (ty) {\n        case \"bool\":\n            return 1;\n        case \"u8\":\n            return 1;\n        case \"i8\":\n            return 1;\n        case \"i16\":\n            return 2;\n        case \"u16\":\n            return 2;\n        case \"u32\":\n            return 4;\n        case \"i32\":\n            return 4;\n        case \"u64\":\n            return 8;\n        case \"i64\":\n            return 8;\n        case \"u128\":\n            return 16;\n        case \"i128\":\n            return 16;\n        case \"bytes\":\n            return 1;\n        case \"string\":\n            return 1;\n        case \"publicKey\":\n            return 32;\n        default:\n            if (\"vec\" in ty) {\n                return 1;\n            }\n            if (\"option\" in ty) {\n                return 1 + typeSize(idl, ty.option);\n            }\n            if (\"defined\" in ty) {\n                const filtered = (_b = (_a = idl.types) === null || _a === void 0 ? void 0 : _a.filter((t) => t.name === ty.defined)) !== null && _b !== void 0 ? _b : [];\n                if (filtered.length !== 1) {\n                    throw new IdlError(`Type not found: ${JSON.stringify(ty)}`);\n                }\n                let typeDef = filtered[0];\n                return accountSize(idl, typeDef);\n            }\n            if (\"array\" in ty) {\n                let arrayTy = ty.array[0];\n                let arraySize = ty.array[1];\n                return typeSize(idl, arrayTy) * arraySize;\n            }\n            throw new Error(`Invalid type ${JSON.stringify(ty)}`);\n    }\n}\n// Not technically sighash, since we don't include the arguments, as Rust\n// doesn't allow function overloading.\nexport function sighash(nameSpace, ixName) {\n    let name = snakeCase(ixName);\n    let preimage = `${nameSpace}:${name}`;\n    return Buffer.from(sha256.digest(preimage)).slice(0, 8);\n}\n//# sourceMappingURL=common.js.map"]},"metadata":{},"sourceType":"module"}