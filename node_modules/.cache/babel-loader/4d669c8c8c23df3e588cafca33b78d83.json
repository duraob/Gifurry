{"ast":null,"code":"import _objectSpread from \"/home/jet/Documents/buildspace/Gifurry/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _toConsumableArray from \"/home/jet/Documents/buildspace/Gifurry/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/home/jet/Documents/buildspace/Gifurry/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/jet/Documents/buildspace/Gifurry/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport camelCase from \"camelcase\";\nimport * as borsh from \"@project-serum/borsh\";\nimport * as bs58 from \"bs58\";\nimport { IdlCoder } from \"./idl\";\nimport { sighash } from \"./common\";\n/**\n * Namespace for state method function signatures.\n */\n\nexport var SIGHASH_STATE_NAMESPACE = \"state\";\n/**\n * Namespace for global instruction function signatures (i.e. functions\n * that aren't namespaced by the state or any of its trait implementations).\n */\n\nexport var SIGHASH_GLOBAL_NAMESPACE = \"global\";\n/**\n * Encodes and decodes program instructions.\n */\n\nexport var InstructionCoder = /*#__PURE__*/function () {\n  function InstructionCoder(idl) {\n    var _this = this;\n\n    _classCallCheck(this, InstructionCoder);\n\n    this.idl = idl;\n    this.ixLayout = InstructionCoder.parseIxLayout(idl);\n    var sighashLayouts = new Map();\n    idl.instructions.forEach(function (ix) {\n      var sh = sighash(SIGHASH_GLOBAL_NAMESPACE, ix.name);\n      sighashLayouts.set(bs58.encode(sh), {\n        layout: _this.ixLayout.get(ix.name),\n        name: ix.name\n      });\n    });\n\n    if (idl.state) {\n      idl.state.methods.map(function (ix) {\n        var sh = sighash(SIGHASH_STATE_NAMESPACE, ix.name);\n        sighashLayouts.set(bs58.encode(sh), {\n          layout: _this.ixLayout.get(ix.name),\n          name: ix.name\n        });\n      });\n    }\n\n    this.sighashLayouts = sighashLayouts;\n  }\n  /**\n   * Encodes a program instruction.\n   */\n\n\n  _createClass(InstructionCoder, [{\n    key: \"encode\",\n    value: function encode(ixName, ix) {\n      return this._encode(SIGHASH_GLOBAL_NAMESPACE, ixName, ix);\n    }\n    /**\n     * Encodes a program state instruction.\n     */\n\n  }, {\n    key: \"encodeState\",\n    value: function encodeState(ixName, ix) {\n      return this._encode(SIGHASH_STATE_NAMESPACE, ixName, ix);\n    }\n  }, {\n    key: \"_encode\",\n    value: function _encode(nameSpace, ixName, ix) {\n      var buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n\n      var methodName = camelCase(ixName);\n      var layout = this.ixLayout.get(methodName);\n\n      if (!layout) {\n        throw new Error(\"Unknown method: \".concat(methodName));\n      }\n\n      var len = layout.encode(ix, buffer);\n      var data = buffer.slice(0, len);\n      return Buffer.concat([sighash(nameSpace, ixName), data]);\n    }\n  }, {\n    key: \"decode\",\n    value:\n    /**\n     * Dewcodes a program instruction.\n     */\n    function decode(ix) {\n      var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"hex\";\n\n      if (typeof ix === \"string\") {\n        ix = encoding === \"hex\" ? Buffer.from(ix, \"hex\") : bs58.decode(ix);\n      }\n\n      var sighash = bs58.encode(ix.slice(0, 8));\n      var data = ix.slice(8);\n      var decoder = this.sighashLayouts.get(sighash);\n\n      if (!decoder) {\n        return null;\n      }\n\n      return {\n        data: decoder.layout.decode(data),\n        name: decoder.name\n      };\n    }\n    /**\n     * Returns a formatted table of all the fields in the given instruction data.\n     */\n\n  }, {\n    key: \"format\",\n    value: function format(ix, accountMetas) {\n      return InstructionFormatter.format(ix, accountMetas, this.idl);\n    }\n  }], [{\n    key: \"parseIxLayout\",\n    value: function parseIxLayout(idl) {\n      var stateMethods = idl.state ? idl.state.methods : [];\n      var ixLayouts = stateMethods.map(function (m) {\n        var fieldLayouts = m.args.map(function (arg) {\n          var _a, _b;\n\n          return IdlCoder.fieldLayout(arg, Array.from([].concat(_toConsumableArray((_a = idl.accounts) !== null && _a !== void 0 ? _a : []), _toConsumableArray((_b = idl.types) !== null && _b !== void 0 ? _b : []))));\n        });\n        var name = camelCase(m.name);\n        return [name, borsh.struct(fieldLayouts, name)];\n      }).concat(idl.instructions.map(function (ix) {\n        var fieldLayouts = ix.args.map(function (arg) {\n          var _a, _b;\n\n          return IdlCoder.fieldLayout(arg, Array.from([].concat(_toConsumableArray((_a = idl.accounts) !== null && _a !== void 0 ? _a : []), _toConsumableArray((_b = idl.types) !== null && _b !== void 0 ? _b : []))));\n        });\n        var name = camelCase(ix.name);\n        return [name, borsh.struct(fieldLayouts, name)];\n      })); // @ts-ignore\n\n      return new Map(ixLayouts);\n    }\n  }]);\n\n  return InstructionCoder;\n}();\n\nvar InstructionFormatter = /*#__PURE__*/function () {\n  function InstructionFormatter() {\n    _classCallCheck(this, InstructionFormatter);\n  }\n\n  _createClass(InstructionFormatter, null, [{\n    key: \"format\",\n    value: function format(ix, accountMetas, idl) {\n      var idlIx = idl.instructions.filter(function (i) {\n        return ix.name === i.name;\n      })[0];\n\n      if (idlIx === undefined) {\n        console.error(\"Invalid instruction given\");\n        return null;\n      }\n\n      var args = idlIx.args.map(function (idlField) {\n        return {\n          name: idlField.name,\n          type: InstructionFormatter.formatIdlType(idlField.type),\n          data: InstructionFormatter.formatIdlData(idlField, ix.data[idlField.name], idl.types)\n        };\n      });\n      var flatIdlAccounts = InstructionFormatter.flattenIdlAccounts(idlIx.accounts);\n      var accounts = accountMetas.map(function (meta, idx) {\n        if (idx < flatIdlAccounts.length) {\n          return _objectSpread({\n            name: flatIdlAccounts[idx].name\n          }, meta);\n        } // \"Remaining accounts\" are unnamed in Anchor.\n        else {\n          return _objectSpread({\n            name: undefined\n          }, meta);\n        }\n      });\n      return {\n        args: args,\n        accounts: accounts\n      };\n    }\n  }, {\n    key: \"formatIdlType\",\n    value: function formatIdlType(idlType) {\n      if (typeof idlType === \"string\") {\n        return idlType;\n      }\n\n      if (\"vec\" in idlType) {\n        return \"Vec<\".concat(this.formatIdlType(idlType.vec), \">\");\n      }\n\n      if (\"option\" in idlType) {\n        return \"Option<\".concat(this.formatIdlType(idlType.option), \">\");\n      }\n\n      if (\"defined\" in idlType) {\n        return idlType.defined;\n      }\n\n      if (\"array\" in idlType) {\n        return \"Array<\".concat(idlType.array[0], \"; \").concat(idlType.array[1], \">\");\n      }\n\n      throw new Error(\"Unknown IDL type: \".concat(idlType));\n    }\n  }, {\n    key: \"formatIdlData\",\n    value: function formatIdlData(idlField, data, types) {\n      var _this2 = this;\n\n      if (typeof idlField.type === \"string\") {\n        return data.toString();\n      } // @ts-ignore\n\n\n      if (idlField.type.vec) {\n        // @ts-ignore\n        return \"[\" + data // @ts-ignore\n        .map(function (d) {\n          return _this2.formatIdlData( // @ts-ignore\n          {\n            name: \"\",\n            type: idlField.type.vec\n          }, d);\n        }).join(\", \") + \"]\";\n      } // @ts-ignore\n\n\n      if (idlField.type.option) {\n        // @ts-ignore\n        return data === null ? \"null\" : this.formatIdlData( // @ts-ignore\n        {\n          name: \"\",\n          type: idlField.type.option\n        }, data);\n      } // @ts-ignore\n\n\n      if (idlField.type.defined) {\n        if (types === undefined) {\n          throw new Error(\"User defined types not provided\");\n        } // @ts-ignore\n\n\n        var filtered = types.filter(function (t) {\n          return t.name === idlField.type.defined;\n        });\n\n        if (filtered.length !== 1) {\n          // @ts-ignore\n          throw new Error(\"Type not found: \".concat(idlField.type.defined));\n        }\n\n        return InstructionFormatter.formatIdlDataDefined(filtered[0], data, types);\n      }\n\n      return \"unknown\";\n    }\n  }, {\n    key: \"formatIdlDataDefined\",\n    value: function formatIdlDataDefined(typeDef, data, types) {\n      if (typeDef.type.kind === \"struct\") {\n        var struct = typeDef.type;\n        var fields = Object.keys(data).map(function (k) {\n          var f = struct.fields.filter(function (f) {\n            return f.name === k;\n          })[0];\n\n          if (f === undefined) {\n            throw new Error(\"Unable to find type\");\n          }\n\n          return k + \": \" + InstructionFormatter.formatIdlData(f, data[k], types);\n        }).join(\", \");\n        return \"{ \" + fields + \" }\";\n      } else {\n        if (typeDef.type.variants.length === 0) {\n          return \"{}\";\n        } // Struct enum.\n\n\n        if (typeDef.type.variants[0].name) {\n          var variants = typeDef.type.variants;\n          var variant = Object.keys(data)[0];\n          var enumType = data[variant];\n          var namedFields = Object.keys(enumType).map(function (f) {\n            var _a;\n\n            var fieldData = enumType[f];\n            var idlField = (_a = variants[variant]) === null || _a === void 0 ? void 0 : _a.filter(function (v) {\n              return v.name === f;\n            })[0];\n\n            if (idlField === undefined) {\n              throw new Error(\"Unable to find variant\");\n            }\n\n            return f + \": \" + InstructionFormatter.formatIdlData(idlField, fieldData, types);\n          }).join(\", \");\n          var variantName = camelCase(variant, {\n            pascalCase: true\n          });\n\n          if (namedFields.length === 0) {\n            return variantName;\n          }\n\n          return \"\".concat(variantName, \" { \").concat(namedFields, \" }\");\n        } // Tuple enum.\n        else {\n          // TODO.\n          return \"Tuple formatting not yet implemented\";\n        }\n      }\n    }\n  }, {\n    key: \"flattenIdlAccounts\",\n    value: function flattenIdlAccounts(accounts, prefix) {\n      // @ts-ignore\n      return accounts.map(function (account) {\n        var accName = sentenceCase(account.name); // @ts-ignore\n\n        if (account.accounts) {\n          var newPrefix = prefix ? \"\".concat(prefix, \" > \").concat(accName) : accName; // @ts-ignore\n\n          return InstructionFormatter.flattenIdlAccounts( // @ts-ignore\n          account.accounts, newPrefix);\n        } else {\n          return _objectSpread(_objectSpread({}, account), {}, {\n            name: prefix ? \"\".concat(prefix, \" > \").concat(accName) : accName\n          });\n        }\n      }).flat();\n    }\n  }]);\n\n  return InstructionFormatter;\n}();\n\nfunction sentenceCase(field) {\n  var result = field.replace(/([A-Z])/g, \" $1\");\n  return result.charAt(0).toUpperCase() + result.slice(1);\n}","map":{"version":3,"sources":["../../../src/coder/instruction.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import camelCase from \"camelcase\";\nimport * as borsh from \"@project-serum/borsh\";\nimport * as bs58 from \"bs58\";\nimport { IdlCoder } from \"./idl\";\nimport { sighash } from \"./common\";\n/**\n * Namespace for state method function signatures.\n */\nexport const SIGHASH_STATE_NAMESPACE = \"state\";\n/**\n * Namespace for global instruction function signatures (i.e. functions\n * that aren't namespaced by the state or any of its trait implementations).\n */\nexport const SIGHASH_GLOBAL_NAMESPACE = \"global\";\n/**\n * Encodes and decodes program instructions.\n */\nexport class InstructionCoder {\n    constructor(idl) {\n        this.idl = idl;\n        this.ixLayout = InstructionCoder.parseIxLayout(idl);\n        const sighashLayouts = new Map();\n        idl.instructions.forEach((ix) => {\n            const sh = sighash(SIGHASH_GLOBAL_NAMESPACE, ix.name);\n            sighashLayouts.set(bs58.encode(sh), {\n                layout: this.ixLayout.get(ix.name),\n                name: ix.name,\n            });\n        });\n        if (idl.state) {\n            idl.state.methods.map((ix) => {\n                const sh = sighash(SIGHASH_STATE_NAMESPACE, ix.name);\n                sighashLayouts.set(bs58.encode(sh), {\n                    layout: this.ixLayout.get(ix.name),\n                    name: ix.name,\n                });\n            });\n        }\n        this.sighashLayouts = sighashLayouts;\n    }\n    /**\n     * Encodes a program instruction.\n     */\n    encode(ixName, ix) {\n        return this._encode(SIGHASH_GLOBAL_NAMESPACE, ixName, ix);\n    }\n    /**\n     * Encodes a program state instruction.\n     */\n    encodeState(ixName, ix) {\n        return this._encode(SIGHASH_STATE_NAMESPACE, ixName, ix);\n    }\n    _encode(nameSpace, ixName, ix) {\n        const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n        const methodName = camelCase(ixName);\n        const layout = this.ixLayout.get(methodName);\n        if (!layout) {\n            throw new Error(`Unknown method: ${methodName}`);\n        }\n        const len = layout.encode(ix, buffer);\n        const data = buffer.slice(0, len);\n        return Buffer.concat([sighash(nameSpace, ixName), data]);\n    }\n    static parseIxLayout(idl) {\n        const stateMethods = idl.state ? idl.state.methods : [];\n        const ixLayouts = stateMethods\n            .map((m) => {\n            let fieldLayouts = m.args.map((arg) => {\n                var _a, _b;\n                return IdlCoder.fieldLayout(arg, Array.from([...((_a = idl.accounts) !== null && _a !== void 0 ? _a : []), ...((_b = idl.types) !== null && _b !== void 0 ? _b : [])]));\n            });\n            const name = camelCase(m.name);\n            return [name, borsh.struct(fieldLayouts, name)];\n        })\n            .concat(idl.instructions.map((ix) => {\n            let fieldLayouts = ix.args.map((arg) => {\n                var _a, _b;\n                return IdlCoder.fieldLayout(arg, Array.from([...((_a = idl.accounts) !== null && _a !== void 0 ? _a : []), ...((_b = idl.types) !== null && _b !== void 0 ? _b : [])]));\n            });\n            const name = camelCase(ix.name);\n            return [name, borsh.struct(fieldLayouts, name)];\n        }));\n        // @ts-ignore\n        return new Map(ixLayouts);\n    }\n    /**\n     * Dewcodes a program instruction.\n     */\n    decode(ix, encoding = \"hex\") {\n        if (typeof ix === \"string\") {\n            ix = encoding === \"hex\" ? Buffer.from(ix, \"hex\") : bs58.decode(ix);\n        }\n        let sighash = bs58.encode(ix.slice(0, 8));\n        let data = ix.slice(8);\n        const decoder = this.sighashLayouts.get(sighash);\n        if (!decoder) {\n            return null;\n        }\n        return {\n            data: decoder.layout.decode(data),\n            name: decoder.name,\n        };\n    }\n    /**\n     * Returns a formatted table of all the fields in the given instruction data.\n     */\n    format(ix, accountMetas) {\n        return InstructionFormatter.format(ix, accountMetas, this.idl);\n    }\n}\nclass InstructionFormatter {\n    static format(ix, accountMetas, idl) {\n        const idlIx = idl.instructions.filter((i) => ix.name === i.name)[0];\n        if (idlIx === undefined) {\n            console.error(\"Invalid instruction given\");\n            return null;\n        }\n        const args = idlIx.args.map((idlField) => {\n            return {\n                name: idlField.name,\n                type: InstructionFormatter.formatIdlType(idlField.type),\n                data: InstructionFormatter.formatIdlData(idlField, ix.data[idlField.name], idl.types),\n            };\n        });\n        const flatIdlAccounts = InstructionFormatter.flattenIdlAccounts(idlIx.accounts);\n        const accounts = accountMetas.map((meta, idx) => {\n            if (idx < flatIdlAccounts.length) {\n                return {\n                    name: flatIdlAccounts[idx].name,\n                    ...meta,\n                };\n            }\n            // \"Remaining accounts\" are unnamed in Anchor.\n            else {\n                return {\n                    name: undefined,\n                    ...meta,\n                };\n            }\n        });\n        return {\n            args,\n            accounts,\n        };\n    }\n    static formatIdlType(idlType) {\n        if (typeof idlType === \"string\") {\n            return idlType;\n        }\n        if (\"vec\" in idlType) {\n            return `Vec<${this.formatIdlType(idlType.vec)}>`;\n        }\n        if (\"option\" in idlType) {\n            return `Option<${this.formatIdlType(idlType.option)}>`;\n        }\n        if (\"defined\" in idlType) {\n            return idlType.defined;\n        }\n        if (\"array\" in idlType) {\n            return `Array<${idlType.array[0]}; ${idlType.array[1]}>`;\n        }\n        throw new Error(`Unknown IDL type: ${idlType}`);\n    }\n    static formatIdlData(idlField, data, types) {\n        if (typeof idlField.type === \"string\") {\n            return data.toString();\n        }\n        // @ts-ignore\n        if (idlField.type.vec) {\n            // @ts-ignore\n            return (\"[\" +\n                data\n                    // @ts-ignore\n                    .map((d) => this.formatIdlData(\n                // @ts-ignore\n                { name: \"\", type: idlField.type.vec }, d))\n                    .join(\", \") +\n                \"]\");\n        }\n        // @ts-ignore\n        if (idlField.type.option) {\n            // @ts-ignore\n            return data === null\n                ? \"null\"\n                : this.formatIdlData(\n                // @ts-ignore\n                { name: \"\", type: idlField.type.option }, data);\n        }\n        // @ts-ignore\n        if (idlField.type.defined) {\n            if (types === undefined) {\n                throw new Error(\"User defined types not provided\");\n            }\n            // @ts-ignore\n            const filtered = types.filter((t) => t.name === idlField.type.defined);\n            if (filtered.length !== 1) {\n                // @ts-ignore\n                throw new Error(`Type not found: ${idlField.type.defined}`);\n            }\n            return InstructionFormatter.formatIdlDataDefined(filtered[0], data, types);\n        }\n        return \"unknown\";\n    }\n    static formatIdlDataDefined(typeDef, data, types) {\n        if (typeDef.type.kind === \"struct\") {\n            const struct = typeDef.type;\n            const fields = Object.keys(data)\n                .map((k) => {\n                const f = struct.fields.filter((f) => f.name === k)[0];\n                if (f === undefined) {\n                    throw new Error(\"Unable to find type\");\n                }\n                return (k + \": \" + InstructionFormatter.formatIdlData(f, data[k], types));\n            })\n                .join(\", \");\n            return \"{ \" + fields + \" }\";\n        }\n        else {\n            if (typeDef.type.variants.length === 0) {\n                return \"{}\";\n            }\n            // Struct enum.\n            if (typeDef.type.variants[0].name) {\n                const variants = typeDef.type.variants;\n                const variant = Object.keys(data)[0];\n                const enumType = data[variant];\n                const namedFields = Object.keys(enumType)\n                    .map((f) => {\n                    var _a;\n                    const fieldData = enumType[f];\n                    const idlField = (_a = variants[variant]) === null || _a === void 0 ? void 0 : _a.filter((v) => v.name === f)[0];\n                    if (idlField === undefined) {\n                        throw new Error(\"Unable to find variant\");\n                    }\n                    return (f +\n                        \": \" +\n                        InstructionFormatter.formatIdlData(idlField, fieldData, types));\n                })\n                    .join(\", \");\n                const variantName = camelCase(variant, { pascalCase: true });\n                if (namedFields.length === 0) {\n                    return variantName;\n                }\n                return `${variantName} { ${namedFields} }`;\n            }\n            // Tuple enum.\n            else {\n                // TODO.\n                return \"Tuple formatting not yet implemented\";\n            }\n        }\n    }\n    static flattenIdlAccounts(accounts, prefix) {\n        // @ts-ignore\n        return accounts\n            .map((account) => {\n            const accName = sentenceCase(account.name);\n            // @ts-ignore\n            if (account.accounts) {\n                const newPrefix = prefix ? `${prefix} > ${accName}` : accName;\n                // @ts-ignore\n                return InstructionFormatter.flattenIdlAccounts(\n                // @ts-ignore\n                account.accounts, newPrefix);\n            }\n            else {\n                return {\n                    ...account,\n                    name: prefix ? `${prefix} > ${accName}` : accName,\n                };\n            }\n        })\n            .flat();\n    }\n}\nfunction sentenceCase(field) {\n    const result = field.replace(/([A-Z])/g, \" $1\");\n    return result.charAt(0).toUpperCase() + result.slice(1);\n}\n//# sourceMappingURL=instruction.js.map"]},"metadata":{},"sourceType":"module"}